# 下载安装

> 官网地址：https://www.rabbitmq.com/
>
> 下载地址：https://www.rabbitmq.com/download.html

## Centos7安装步骤

### 软件包安装

```shell
# 导入erlang rpm
curl -1sLf 'https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/setup.rpm.sh' | sudo -E bash
# 导入rabbitmq rpm
curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash
# 执行安装
yum install -y rabbitmq-server
```

### 安装延时插件

```shell
cd  /usr/lib/rabbitmq/lib/ && ll
```

![image-20220326111512707](https://img-file.lemonzuo.com/img/202203261115852.png)

```shell
cd rabbitmq_server-3.9.14/plugins/
# 下载延时插件
wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.9.0/rabbitmq_delayed_message_exchange-3.9.0.ez
# 启用插件
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
```

### 启用WEB管理界面

```shell
rabbitmq-plugins enable rabbitmq_management
```

### 账户配置

```shell
# 启动MQ
systemctl start rabbitmq-server
# 切换目录
cd ../sbin/
# 新增用户
# rabbitmqctl add_user 用户名 密码
rabbitmqctl add_user rabbitmq@admin zhq%QCJ1WSFEPAMAulMoNqYkp0D9Uv
# 授权
rabbitmqctl set_permissions -p / rabbitmq@admin ".*" ".*" ".*"
# 设置为管理员账户
rabbitmqctl set_user_tags rabbitmq@admin administrator
```

# 集群配置

> 参考连接: https://blog.csdn.net/qq_28533563/article/details/107932737

- 配置hosts

  ```shell
  cat >> /etc/hosts <<EOF
  192.168.0.12 rabbit-node1
  192.168.0.14 rabbit-node2
  192.168.0.15 rabbit-node3
  EOF
  ```

  

- 配置cookie

  复制主节点上的/var/lib/rabbitmq/.erlang.cookie到从节点上

  > 注意事项
  >
  > 1. 从节点/var/lib/rabbitmq/.erlang.cookie权限需改为600 
  >
  > ```shell
  > chmod 600 /var/lib/rabbitmq/.erlang.cookie
  > ```
  >
  > 2. 从节点/var/lib/rabbitmq/.erlang.cookie更改拥有者
  >
  > ~~~shell
  > chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie
  > ~~~

 - 启动服务

   ~~~shell
   # 所有节点上启动服务
   systemctl start rabbitmq-server
   ~~~

 - 从节点加入集群

   ~~~shell
   # 1.停止服务
   rabbitmqctl stop_app
   # 2.重置状态
   rabbitmqctl reset
   # 3.节点加入, 在一个node加入cluster之前，必须先停止该node的rabbitmq应用，即先执行stop_app
   # rabbit-node2加入node1, rabbit-node3加入node2
   rabbitmqctl join_cluster rabbit@rabbit-node1
   # 4.启动服务
   rabbitmqctl start_app
   ~~~

 - 查看集群状态

   ~~~shell
   rabbitmqctl cluster_status
   ~~~



# 图像化管理界面

- 图像化界面

![image-20210415212356291](https://img-file.lemonzuo.com/img/20210415212356.png)

# 简单模式

- pom依赖

    ~~~xml
    <dependency>
        <groupId>com.rabbitmq</groupId>
        <artifactId>amqp-client</artifactId>
        <version>5.10.0</version>
    </dependency>
    ~~~

- 生产者

    ~~~java
    public class Producer {
        private static final String QUEUE_NAME = "SIMPLE_MODEL";
    
        public static void main(String[] args) {
            Connection connection = null;
            Channel channel = null;
            try {
                // 1.创建连接工厂
                ConnectionFactory factory = new ConnectionFactory();
                factory.setHost("8.134.12.132");
                factory.setPort(5672);
                factory.setUsername("admin");
                factory.setPassword("admin");
                factory.setVirtualHost("/");
                // 2.创建连接Connection
                connection = factory.newConnection("producer");
                // 3.创建通道Channel
                channel = connection.createChannel();
                // 4.创建交换机，声明队列，绑定关系，路由key,发送消息，接收消息
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                channel.queueDeclare(QUEUE_NAME, false, false, false, null);
                // 5.准备消息内容
                String message = "RabbitMQ";
                // 6.发送消息给队列
                // 参数一：发送到哪一个交换机
                // 参数二：路由的key值，本次是队列名称
                // 参数三：其他参数信息
                // 参数四：待发送消息的消息体
                channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
                System.out.println("消息发送成功=====>");
            } catch (IOException | TimeoutException e) {
                e.printStackTrace();
            } finally {
                // 7.关闭通道
                if (channel != null && channel.isOpen()) {
                    try {
                        channel.close();
                    } catch (IOException | TimeoutException e) {
                        e.printStackTrace();
                    }
                }
                // 8.关闭连接
                if (connection != null && connection.isOpen()) {
                    try {
                        connection.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class Consumer {
        private static final String QUEUE_NAME = "SIMPLE_MODEL";
    
        public static void main(String[] args) {
            Connection connection = null;
            Channel channel = null;
            try {
                // 1.创建连接工厂
                ConnectionFactory factory = new ConnectionFactory();
                factory.setHost("8.134.12.132");
                factory.setPort(5672);
                factory.setUsername("admin");
                factory.setPassword("admin");
                factory.setVirtualHost("/");
                // 2.创建连接Connection
                connection = factory.newConnection("producer");
                // 3.创建通道Channel
                channel = connection.createChannel();
                // 4. 接收消息
                // 消费成功
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    System.out.println("收到的消息为========>");
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                };
                // 取消消费
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费消息");
                };
                // 参数一：消费的队列名称
                // 参数二：消费成功后是否自动应答
                // 参数三：消费者消费成功回调
                // 参数四：消费者取消消费回调
                channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
            } catch (IOException | TimeoutException e) {
                e.printStackTrace();
            } finally {
                // 5.关闭通道
                if (channel != null && channel.isOpen()) {
                    try {
                        channel.close();
                    } catch (IOException | TimeoutException e) {
                        e.printStackTrace();
                    }
                }
                // 6.关闭连接
                if (connection != null && connection.isOpen()) {
                    try {
                        connection.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ~~~
    
# 工作队列模式

1. 自动应答

    - 生产者

        ~~~java
        public class Task01 {
            private static final String QUEUE_NAME = "WORK_MODEL";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                channel.queueDeclare(QUEUE_NAME, false, false, false, null);
                for (int i = 1; i <= 10; i++) {
                    channel.basicPublish("", QUEUE_NAME, null, String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消费者

        ~~~java
        public class Work01 {
            private static final String QUEUE_NAME = "WORK_MODEL";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 消费成功
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    System.out.println("收到的消息为========>");
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                };
                // 取消消费
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费消息");
                };
                System.out.println("WORK-2-start");
                // 异步执行消费
                channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
                System.out.println("WORK-2-end");
            }
        }
        ~~~

        

2. 手动应答

    - 生产者

        ~~~java
        public class Task02 {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                channel.queueDeclare(QUEUE_NAME, false, false, false, null);
                for (int i = 11; i <= 20; i++) {
                    channel.basicPublish("", QUEUE_NAME, null, String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消费者

        ~~~java
        public class Work02 {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                System.out.println("WORK-2-start");
                Channel channel = RabbitMqUtils.getChannel();
                // 消费成功
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("收到的消息为========>");
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    // 消息的标记
                    long deliveryTag = message.getEnvelope().getDeliveryTag();
                    // 是否批量应答本信道内所有消息
                    boolean multiple = false;
                    // 执行应答
                    channel.basicAck(deliveryTag, multiple);
                };
                // 取消消费
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费消息");
                };
                // 异步执行消费,手动应答
                channel.basicConsume(QUEUE_NAME, false, deliverCallback, cancelCallback);
            }
        }
        ~~~

        

3. 数据持久化

    - 队列持久化

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-03 22:54
         * 队列持久化
         */
        public class TaskQueueDurable {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK_DURABLE";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                // 队列持久化
                boolean durable = true;
                channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
                for (int i = 11; i <= 20; i++) {
                    channel.basicPublish("", QUEUE_NAME, null, String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消息持久化

        ~~~java
        public class TaskQueueAndMessageDurable {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK_QUEUE_MESSAGE_DURABLE";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                // 队列持久化
                boolean durable = true;
                channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
                for (int i = 11; i <= 20; i++) {
                    // 发送消息，且持久化消息
                    // 新增MessageProperties.PERSISTENT_TEXT_PLAIN
                    channel.basicPublish("", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,
                            String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

4. 不公平分发

    ~~~java
    /**
     * @author LemonZuo
     * @create 2021-07-03 22:45
     * 不公平分发
     */
    public class WorkPrefetch {
        private static final String QUEUE_NAME = "WORK_MODEL_ACK";
    
        public static void main(String[] args) throws IOException, TimeoutException {
            System.out.println("WORK-3-start");
            Channel channel = RabbitMqUtils.getChannel();
            // 消费成功
            DeliverCallback deliverCallback = (consumerTag, message) -> {
                try {
                    TimeUnit.SECONDS.sleep(30);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("收到的消息为========>");
                System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                // 消息的标记
                long deliveryTag = message.getEnvelope().getDeliveryTag();
                // 是否批量应答本信道内所有消息
                boolean multiple = false;
                // 执行应答
                channel.basicAck(deliveryTag, multiple);
            };
            // 取消消费
            CancelCallback cancelCallback = consumerTag -> {
                System.out.println("取消消费消息");
            };
            // 不公平分发
            int prefetch = 1;
            channel.basicQos(prefetch);
            // 异步执行消费,手动应答
            channel.basicConsume(QUEUE_NAME, false, deliverCallback, cancelCallback);
        }
    }
    ~~~

5. 预取值

    - 生产者

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-03 22:54
         * 预取值
         */
        public class Task {
            private static final String QUEUE_NAME = "WORK_MODEL_PREFETCH";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                // 队列持久化
                boolean durable = true;
                channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
                Scanner scanner = new Scanner(System.in);
                String str;
                do {
                    str = scanner.next();
                    // 发送消息，且持久化消息
                    // 新增MessageProperties.PERSISTENT_TEXT_PLAIN
                    channel.basicPublish("", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, str.getBytes(StandardCharsets.UTF_8));
                } while (!"end".equalsIgnoreCase(str));
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消费者

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-04 11:34
         */
        public class Work01 {
            private static final String QUEUE_NAME = "WORK_MODEL_PREFETCH";
        
            public static void main(String[] args) {
                Channel channel = RabbitMqUtils.getChannel();
        
                try {
                    TimeUnit.SECONDS.sleep(1);
                    assert channel != null;
                    // prefetchCount: 0-公平/轮询分发，1-不公平分发，>=2 -预取值
                    int prefetchCount = 2;
                    channel.basicQos(prefetchCount);
                    DeliverCallback deliverCallback = (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                        long deliveryTag = message.getEnvelope().getDeliveryTag();
                        channel.basicAck(deliveryTag, false);
                    };
                    channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

6. 发布确认

    - 生产者

        ~~~java
        public class ConfirmMessage {
            public static void main(String[] args) {
                // 单个确认 11312MS
                // confirmSingle();
                // 批量发布确认 200MS
                // confirmBatch();
                // 异步确认 120MS
                // confirmAsync();
            }
        
            public static void confirmSingle() {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 开启发布确认
                    channel.confirmSelect();
                    // 60e164ef22158c3ee7788a69
                    String queueName = IdUtil.objectId();
                    // 申明队列
                    channel.queueDeclare(queueName, true, false, false, null);
                    TimeInterval timer = DateUtil.timer();
                    for (int i = 0; i < 1000; i++) {
                        String message = String.valueOf(i);
                        channel.basicPublish("", queueName, MessageProperties.PERSISTENT_TEXT_PLAIN,
                                message.getBytes(StandardCharsets.UTF_8));
                        boolean confirms = channel.waitForConfirms();
                        if (confirms) {
                            System.out.println("发布消息成功");
                        }
                    }
                    System.out.println("耗时：" + timer.interval());
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
        
            public static void confirmBatch() {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 开启发布确认
                    channel.confirmSelect();
                    // 60e167db22159c5f90a586ac
                    String queueName = IdUtil.objectId();
                    // 申明队列
                    channel.queueDeclare(queueName, true, false, false, null);
                    // 批量大小
                    int batchSize = 100;
                    TimeInterval timer = DateUtil.timer();
                    for (int i = 0; i < 1000; i++) {
                        String message = String.valueOf(i);
                        channel.basicPublish("", queueName, MessageProperties.PERSISTENT_TEXT_PLAIN,
                                message.getBytes(StandardCharsets.UTF_8));
                        if ((i + 1) % batchSize == 0) {
                            boolean confirms = channel.waitForConfirms();
                            if (confirms) {
                                System.out.println("发布消息成功");
                            }
                        }
                    }
                    System.out.println("耗时：" + timer.interval());
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
        
            public static void confirmAsync() {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 开启发布确认
                    channel.confirmSelect();
                    // 线程安全有序的哈希表
                    ConcurrentSkipListMap<Long, String> container = new ConcurrentSkipListMap<>();
                    // 60e16b132215319e0d197747
                    String queueName = IdUtil.objectId();
                    // 申明队列
                    channel.queueDeclare(queueName, true, false, false, null);
                    // 消息监听器
                    // 成功回调
                    ConfirmCallback ackCallback = (deliveryTag, multiple) -> {
                        System.out.println("确认的消息编号：" + deliveryTag);
                        if (multiple) {
                            ConcurrentNavigableMap<Long, String> confirmed = container.headMap(deliveryTag);
                            confirmed.clear();
                        } else {
                            container.remove(deliveryTag);
                        }
                    };
                    // 失败回调
                    ConfirmCallback nackCallback = (deliveryTag, multiple) -> {
                        System.out.println("未确认的消息编号：" + deliveryTag);
                    };
                    channel.addConfirmListener(ackCallback, nackCallback);
                    TimeInterval timer = DateUtil.timer();
                    for (int i = 0; i < 1000; i++) {
                        String message = String.valueOf(i);
                        channel.basicPublish("", queueName, MessageProperties.PERSISTENT_TEXT_PLAIN,
                                message.getBytes(StandardCharsets.UTF_8));
                        container.put(channel.getNextPublishSeqNo(), message);
                    }
                    System.out.println("耗时：" + timer.interval());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

# 发布订阅模式

- 生产者

    ~~~java
    /**
     * @author LemonZuo
     * @create 2021-07-04 23:23
     */
    public class EmitLog {
        private final static String EXCHANGE_NAME = "logs";
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
                Scanner scanner = new Scanner(System.in);
                while (scanner.hasNext()) {
                    String message = scanner.next();
                    // 推送消息
                    channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes(StandardCharsets.UTF_8));
                    System.out.println("消息推送成功：".concat(message));
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class ReceiveLog01 {
        private final static String EXCHANGE_NAME = "logs";
    
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
                // 生成临时队列
                String queueName = channel.queueDeclare().getQueue();
                // 交换机与队列进行绑定
                channel.queueBind(queueName, EXCHANGE_NAME, "");
                // 消费成功回调
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                };
                // 取消消费回调
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费");
                };
                // 接收消息
                System.out.println("ReceiveLog-01 等待接收消息");
                channel.basicConsume(queueName, deliverCallback, cancelCallback);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~



# 直接模式

- 生产者

    ~~~java
    public class DirectLog {
        private final static String EXCHANGE_NAME = "DIRECT_LOG";
    
        public static void main(String[] args) {
            try {
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                Scanner scanner = new Scanner(System.in);
                while (scanner.hasNext()) {
                    String message = scanner.next();
                    String[] str = message.split(";");
    
                    // 推送消息
                    channel.basicPublish(EXCHANGE_NAME, str[0], null, str[1].getBytes(StandardCharsets.UTF_8));
                    System.out.println("消息推送成功：消息类型".concat(str[0]).concat(" 消息内容：").concat(str[1]));
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class ReceiveConsoleLog {
        private final static String EXCHANGE_NAME = "DIRECT_LOG";
    
        public static void main(String[] args) {
            try {
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明直接交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                channel.queueDeclare("console", false, false, false, null);
                channel.queueBind("console", EXCHANGE_NAME, "info");
                channel.queueBind("console", EXCHANGE_NAME, "warn");
                System.out.println("等待接收消息");
                channel.basicConsume("console",
                        (consumerTag, message) -> System.out.println(new String(message.getBody(), StandardCharsets.UTF_8)),
                        consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    ~~~java
    public class ReceiveErrorLog {
        private final static String EXCHANGE_NAME = "DIRECT_LOG";
    
        public static void main(String[] args) {
            try {
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明直接交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                channel.queueDeclare("disk", false, false, false, null);
                channel.queueBind("disk", EXCHANGE_NAME, "error");
                System.out.println("等待接收消息");
                channel.basicConsume("disk",
                        (consumerTag, message) -> System.out.println(new String(message.getBody(), StandardCharsets.UTF_8)),
                        consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

# 主题模式

- 生产者

    ~~~java
    public class EmitLogs {
        private static final String EXCHANGE_NAME = "topic_logs";
    
        public static void main(String[] args) {
            Map<String, String> messages = new HashMap<>();
            messages.put("quick.orange.rabbit", "被队列 Q1Q2 接收到");
            messages.put("lazy.orange.elephant", "被队列 Q1Q2 接收到");
            messages.put("quick.orange.fox", "被队列 Q1 接收到");
            messages.put("azy.brown.fox", "被队列 Q2 接收到");
            messages.put("lazy.pink.rabbit", "虽然满足两个绑定但只被队列 Q2 接收一次");
            messages.put("quick.brown.fox", "不匹配任何绑定不会被任何队列接收到会被丢弃");
            messages.put("quick.orange.male.rabbit", "是四个单词不匹配任何绑定会被丢弃");
            messages.put("lazy.orange.male.rabbit", "是四个单词但匹配 Q2");
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明主题交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
                messages.forEach((key, value) -> {
                    try {
                        // 推送消息
                        channel.basicPublish(EXCHANGE_NAME, key, null, value.getBytes(StandardCharsets.UTF_8));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class TopicReceiveLog01 {
        private static final String EXCHANGE_NAME = "topic_logs";
    
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明主题交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
                // 声明队列
                channel.queueDeclare("Q1", false, false, false, null);
                // 交换机绑定队列
                channel.queueBind("Q1", EXCHANGE_NAME, "*.orange.*");
                channel.basicConsume("Q1", true, (consumerTag, message) -> {
                    System.out.println("routeKey: ".concat(message.getEnvelope().getRoutingKey()).concat(" message:").concat(new String(message.getBody(), StandardCharsets.UTF_8)));
                },consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    ~~~java
    public class TopicReceiveLog02 {
        private static final String EXCHANGE_NAME = "topic_logs";
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明主题交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
                // 声明队列
                channel.queueDeclare("Q2", false, false, false, null);
                // 交换机绑定队列
                channel.queueBind("Q2", EXCHANGE_NAME, "*.*.rabbit");
                channel.queueBind("Q2", EXCHANGE_NAME, "lazy.#");
                channel.basicConsume("Q2", true, (consumerTag, message) -> {
                    System.out.println("routeKey: ".concat(message.getEnvelope().getRoutingKey()).concat(" message:").concat(new String(message.getBody(), StandardCharsets.UTF_8)));
                },consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~



# 死信队列

- 消息超时

    - 生产者

        ~~~java
        public class Producer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 构建超时参数 单位毫秒
                    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                            .expiration("10000").build();
                    for (int i = 1; i < 11; i++) {
                        String message = "info" + i;
                        channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, properties, message.getBytes(StandardCharsets.UTF_8));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 普通消费者

        ~~~java
        public class NormalConsumer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        
        
                    // 声明普通交换机
                    channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明普通队列
                    Map<String, Object> arguments = new HashMap<>(4);
                    // 绑定死信交换机
                    arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
                    // 死信队列使用的routing-key
                    arguments.put("x-dead-letter-routing-key", DEAD_ROUTING_KEY);
        
                    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        
                    // 普通交换机与普通队列绑定
                    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
                    System.out.println("普通消费者等待接收消息");
                    channel.basicConsume(NORMAL_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 死信消费者

        ~~~java
        public class DeadConsumer {
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    // 死信交换机与死信队列绑定
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
                    System.out.println("死信消费者等待接收消息");
                    channel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

- 队列达最大长度

    - 生产者

        ~~~java
        public class Producer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 构建超时参数 单位毫秒
                    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                            .expiration("10000").build();
                    for (int i = 1; i < 11; i++) {
                        String message = "info" + i;
                        channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, null, message.getBytes(StandardCharsets.UTF_8));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 正常消费者

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-06 12:46
         * 死信队列正常消费者
         */
        public class NormalConsumerMaxLength {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        
        
                    // 声明普通交换机
                    channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明普通队列
                    Map<String, Object> arguments = new HashMap<>(4);
                    // 绑定死信交换机
                    arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
                    // 死信队列使用的routing-key
                    arguments.put("x-dead-letter-routing-key", DEAD_ROUTING_KEY);
                    // 队列最大长度
                    arguments.put("x-max-length", 6);
        
                    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        
                    // 普通交换机与普通队列绑定
                    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
                    System.out.println("普通消费者等待接收消息");
                    channel.basicConsume(NORMAL_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 死信消费者

        ~~~java
        public class DeadConsumer {
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    // 死信交换机与死信队列绑定
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
                    System.out.println("死信消费者等待接收消息");
                    channel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

- 消息被拒

    - 生产者

        ~~~java
        public class Producer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 构建超时参数 单位毫秒
                    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                            .expiration("10000").build();
                    for (int i = 1; i < 11; i++) {
                        String message = "info" + i;
                        channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, null, message.getBytes(StandardCharsets.UTF_8));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 正常消费者

        ~~~java
        public class NormalConsumerReject {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        
        
                    // 声明普通交换机
                    channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明普通队列
                    Map<String, Object> arguments = new HashMap<>(4);
                    // 绑定死信交换机
                    arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
                    // 死信队列使用的routing-key
                    arguments.put("x-dead-letter-routing-key", DEAD_ROUTING_KEY);
        
                    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        
                    // 普通交换机与普通队列绑定
                    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
                    System.out.println("普通消费者等待接收消息");
                    channel.basicConsume(NORMAL_QUEUE, false, (consumerTag, message) -> {
                        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
                        // 拒绝消息
                        if ("info5".equals(msg)) {
                            channel.basicReject(message.getEnvelope().getDeliveryTag(), false);
                        } else {
                            System.out.println(msg);
                            channel.basicAck(message.getEnvelope().getDeliveryTag(), false);
                        }
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 死信 消费者

        ~~~java
        public class DeadConsumer {
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    // 死信交换机与死信队列绑定
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
                    System.out.println("死信消费者等待接收消息");
                    channel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        
        ~~~
        
    
    

# 延迟队列

- 基于死信队列

  - 架构图

  ![image-20220102212337267](https://img-file.lemonzuo.com/img/202201022123334.png)

  - 配置类

    ~~~java
    import org.springframework.amqp.core.*;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    /**
     * @author LemonZuo
     * @create 2022-01-02 13:20
     */
    @Configuration
    public class TtlQueueConfig {
        /**
         * 普通交换机
         */
        private static final String NORMAL_EXCHANGE = "X";
        /**
         * 死信交换机
         */
        private static final String DEAD_EXCHANGE = "Y";
        /**
         * 队列QA
         */
        private static final String NORMAL_QUEUE_QA = "QA";
        /**
         * 队列QB
         */
        private static final String NORMAL_QUEUE_QB = "QB";
        /**
         * 队列QC
         */
        private static final String NORMAL_QUEUE_QC = "QC";
        /**
         * 死信队列QD
         */
        private static final String DEAD_QUEUE_QD = "QD";
    
        @Bean(name = "normalExchange")
        public DirectExchange normalExchange() {
            return new DirectExchange(NORMAL_EXCHANGE);
        }
    
        /**
         * 构建死信交换机
         * @return
         */
        @Bean(name = "deadExchange")
        public DirectExchange deadExchange() {
            return new DirectExchange(DEAD_EXCHANGE);
        }
    
        @Bean(name = "normalQueueQa")
        public Queue normalQueueQa() {
            Map<String, Object> arguments = new HashMap<>(16);
            // 设置死信交换机
            arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
            // 死信队列 routing-key
            arguments.put("x-dead-letter-routing-key", "YD");
            // 消息过期时间 10S
            arguments.put("x-message-ttl", 10000);
            return QueueBuilder.durable(NORMAL_QUEUE_QA).withArguments(arguments).build();
        }
    
        @Bean(name = "normalQueueQb")
        public Queue normalQueueQb() {
            Map<String, Object> arguments = new HashMap<>(16);
            // 设置死信交换机
            arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
            // 死信队列 routing-key
            arguments.put("x-dead-letter-routing-key", "YD");
            // 消息过期时间 40S
            arguments.put("x-message-ttl", 40000);
            return QueueBuilder.durable(NORMAL_QUEUE_QB).withArguments(arguments).build();
        }
    
    
        @Bean(name = "normalQueueQc")
        public Queue normalQueueQc() {
            Map<String, Object> arguments = new HashMap<>(16);
            // 设置死信交换机
            arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
            // 死信队列 routing-key
            arguments.put("x-dead-letter-routing-key", "YD");
            return QueueBuilder.durable(NORMAL_QUEUE_QC).withArguments(arguments).build();
        }
    
        /**
         * 构建死信队列
         * @return
         */
        @Bean(name = "deadQueueQd")
        public Queue deadQueueQd() {
            return QueueBuilder.durable(DEAD_QUEUE_QD).build();
        }
    
        @Bean
        public Binding queueABingX(Queue normalQueueQa, DirectExchange normalExchange) {
            return BindingBuilder.bind(normalQueueQa).to(normalExchange).with("XA");
        }
    
        @Bean
        public Binding queueBBingX(Queue normalQueueQb, DirectExchange normalExchange) {
            return BindingBuilder.bind(normalQueueQb).to(normalExchange).with("XB");
        }
    
        @Bean
        public Binding queueCBingX(Queue normalQueueQc, DirectExchange normalExchange) {
            return BindingBuilder.bind(normalQueueQc).to(normalExchange).with("XC");
        }
    
        @Bean
        public Binding queueDBingY(Queue deadQueueQd, DirectExchange deadExchange) {
            return BindingBuilder.bind(deadQueueQd).to(deadExchange).with("YD");
        }
    
    }
    ~~~

    

  - 生产者

    ~~~java
    import cn.hutool.core.date.DateUtil;
    import com.lemonzuo.config.DelayedQueueConfig;
    import io.swagger.annotations.Api;
    import io.swagger.annotations.ApiOperation;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.core.MessagePostProcessor;
    import org.springframework.amqp.rabbit.core.RabbitTemplate;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    import javax.annotation.Resource;
    
    /**
     * @author LemonZuo
     * @create 2022-01-02 13:54
     */
    @Api(tags = "发送消息")
    @Slf4j
    @RestController
    @RequestMapping("/ttl")
    public class SendMsgController {
        @Resource
        private RabbitTemplate rabbitTemplate;
    
        @ApiOperation("发送消息")
        @GetMapping("/sendMsg/{msg}")
        public void sendMsg(@PathVariable String msg) {
            log.info("当前时间:{}, 发送一条消息给两个TTL队列:{}", DateUtil.now(), msg);
            rabbitTemplate.convertAndSend("X", "XA", "消息来自TTL1为10s的消息队列"+msg);
            rabbitTemplate.convertAndSend("X", "XB", "消息来自TTL1为40s的消息队列"+msg);
        }
    
        @ApiOperation("发送消息带过期时间")
        @GetMapping("/sendMessageWithExpireTime/{msg}/{expireTime}")
        public void sendMessageWithExpireTime(@PathVariable String msg, @PathVariable String expireTime) {
            log.info("当前时间:{}, 发送一条时长:{}毫秒的消息给QC队列:{}", DateUtil.now(), expireTime, msg);
    
            rabbitTemplate.convertAndSend("X", "XC", msg, messagePostProcessor ->{
                // 设置过期时间
                messagePostProcessor.getMessageProperties().setExpiration(expireTime);
                return messagePostProcessor;
            });
        }
    }
    ~~~

  - 消费者

    ~~~java
    import cn.hutool.core.date.DateUtil;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.amqp.core.Message;
    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.stereotype.Component;
    
    /**
     * @author LemonZuo
     * @create 2022-01-02 14:01
     */
    @Slf4j
    @Component
    public class DeadQueueConsumer {
    
        @RabbitListener(queues = "QD")
        public void receiveMessage(Message message) {
            String msg = new String(message.getBody());
            log.info("当前时间:{}, 收到死信队列的消息:{}", DateUtil.now(),msg);
        }
    }
    ~~~

  - 存在问题

    ![image-20220102213114763](https://img-file.lemonzuo.com/img/202201022131803.png)

    ~~~txt
    由于队列先进先出的特性，每次只能检测头部消息是否超时，导致队列阻塞，存在非头部消息已经超时但由于头部消息未到超时时间，一致无法被投递到死信队列中
    ~~~

    

- 基于插件实现

  - 插件安装(rabbitmq_delayed_message_exchange)

    ~~~html
    参考链接:https://www.cnblogs.com/geekdc/p/13549613.html
    ~~~

  - 架构图

  ![image-20220102213141150](https://img-file.lemonzuo.com/img/202201022131185.png)

  - 配置类

    ~~~java
    import org.springframework.amqp.core.*;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import java.util.HashMap;
    import java.util.Map;
    
    /**
     * 基于延迟插件延迟队列配置列
     * @author LemonZuo
     * @create 2022-01-02 20:28
     */
    @Configuration
    public class DelayedQueueConfig {
        /**
         * 延迟队列交换机名称
         */
        public static final String DELAYED_PLUGIN_EXCHANGE_NAME = "delayed_plugin_exchange";
        /**
         * 延迟队列名称
         */
        public static final String DELAYED_PLUGIN_QUEUE_NAME = "delayed_plugin_queue";
        /**
         * 延迟队列 routing Key
         */
        public static final String DELAYED_PLUGIN_ROUTING_KEY = "delayed_plugin_routing_key";
    
        /**
         * 声明基于插件的交换机
         * @return
         */
        @Bean(name = "delayedPluginExchange")
        public CustomExchange delayedPluginExchange() {
            Map<String, Object> arguments = new HashMap<>(16);
            // 延迟类型
            arguments.put("x-delayed-type", "direct");
            return new CustomExchange(DELAYED_PLUGIN_EXCHANGE_NAME, "x-delayed-message",true, false, arguments);
        }
    
    
        /**
         * 生命队列
         * @return
         */
        @Bean(name = "delayedPluginQueue")
        public Queue delayedPluginQueue() {
            return QueueBuilder.durable(DELAYED_PLUGIN_QUEUE_NAME).build();
        }
    
        @Bean(name = "pluginQueueBindingExchange")
        public Binding pluginQueueBindingExchange(Exchange delayedPluginExchange, Queue delayedPluginQueue) {
            return BindingBuilder.bind(delayedPluginQueue).to(delayedPluginExchange).with(DELAYED_PLUGIN_ROUTING_KEY).noargs();
        }
    }
    ~~~

    

  - 生产者

  ~~~java
  import cn.hutool.core.date.DateUtil;
  import com.lemonzuo.config.DelayedQueueConfig;
  import io.swagger.annotations.Api;
  import io.swagger.annotations.ApiOperation;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.core.MessagePostProcessor;
  import org.springframework.amqp.rabbit.core.RabbitTemplate;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PathVariable;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  import javax.annotation.Resource;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 13:54
   */
  @Api(tags = "发送消息")
  @Slf4j
  @RestController
  @RequestMapping("/ttl")
  public class SendMsgController {
      @Resource
      private RabbitTemplate rabbitTemplate;
  
      @ApiOperation("基于插件发送消息带过期时间")
      @GetMapping("/sendMessageWithExpireTimeWithPlugin/{msg}/{expireTime}")
      public void sendMessageWithExpireTimeWithPlugin(@PathVariable String msg, @PathVariable Integer expireTime) {
          log.info("当前时间:{}, 发送一条时长:{}毫秒的消息给delayed_plugin_queue队列:{}", DateUtil.now(), expireTime, msg);
  
          rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_PLUGIN_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_PLUGIN_ROUTING_KEY, msg, messagePostProcessor ->{
              // 设置过期时间
              messagePostProcessor.getMessageProperties().setDelay(expireTime);
              return messagePostProcessor;
          });
  
      }
  }
  ~~~

  

  - 消费者

  ~~~java
  import cn.hutool.core.date.DateUtil;
  import com.lemonzuo.config.DelayedQueueConfig;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.core.Message;
  import org.springframework.amqp.rabbit.annotation.RabbitListener;
  import org.springframework.stereotype.Component;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 14:01
   */
  @Slf4j
  @Component
  public class DeadQueueConsumer {
  
      @RabbitListener(queues = DelayedQueueConfig.DELAYED_PLUGIN_QUEUE_NAME)
      public void deadReceiveMessage(Message message) {
          String msg = new String(message.getBody());
          log.info("当前时间:{}, 基于插件延迟队列接收到消息:{}", DateUtil.now(),msg);
      }
  }
  ~~~

  

# 整合SpringBoot

- pom.xml

~~~xml
<!--RabbitMQ 依赖-->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
~~~

- applicatin.yml

  ~~~yaml
  spring:
    rabbitmq:
      host: ip
      port: port
      username: username
      password: password
      virtual-host: /
  ~~~

  

# 发布确认

## 交换机消息确认

- application.yml

  ~~~yaml
  spring:
    rabbitmq:
      # 发布确认
      publisher-confirm-type: correlated
  ~~~

  NONE: 禁用发布确认模式，是默认值
  CORRELATED: 发布消息成功到交换器后会触发回调方法
  SIMPLE: 经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，
  其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker

- 配置类

  ~~~java
  import org.springframework.amqp.core.*;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  /**
   * 发布确认配置
   * @author LemonZuo
   * @create 2022-01-02 23:31
   */
  @Configuration
  public class ConfirmConfig {
      public static final String EXCHANGE_NAME = "confirm.exchange";
      public static final String QUEUE_NAME = "confirm.queue";
      public static final String ROUTING_KEY = "confirm.routing.key";
  
      @Bean
      public Exchange confirmExchange() {
          return new DirectExchange(EXCHANGE_NAME, true, false);
      }
  
      @Bean
      public Queue confirmQueue() {
          return QueueBuilder.durable(QUEUE_NAME).build();
      }
  
      @Bean
      public Binding confirmBinding(Queue confirmQueue, Exchange confirmExchange) {
          return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(ROUTING_KEY).noargs();
      }
  }
  ~~~

  

- 生产者

  ~~~java
  import cn.hutool.core.util.IdUtil;
  import com.lemonzuo.config.ConfirmConfig;
  import io.swagger.annotations.Api;
  import io.swagger.annotations.ApiImplicitParam;
  import io.swagger.annotations.ApiImplicitParams;
  import io.swagger.annotations.ApiOperation;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.rabbit.connection.CorrelationData;
  import org.springframework.amqp.rabbit.core.RabbitTemplate;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PathVariable;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  import javax.annotation.Resource;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 23:44
   */
  @Slf4j
  @RestController
  @Api(tags = "消息发布确认")
  @RequestMapping("/confirm")
  public class ConfirmController {
      @Resource
      private RabbitTemplate rabbitTemplate;
  
      @ApiOperation("发送发布确认消息")
      @ApiImplicitParams({
           @ApiImplicitParam(name = "msg", value = "消息内容", paramType = "path")
      })
      @GetMapping("/sendConfirmMessage/{msg}")
      public void sendConfirmMessage(@PathVariable String msg) {
          // 交换机消息发布确认
          rabbitTemplate.setConfirmCallback((CorrelationData correlationData, boolean ack, String cause) -> {
              if (ack) {
                  log.info("交换机接收消息成功: ID:{}", (correlationData != null ? correlationData.getId() : ""));
              } else {
                  log.info("交换机未收到Id:{}的消息，原因:{}", (correlationData != null ? correlationData.getId() : ""), cause);
              }
          });
          CorrelationData correlationData = new CorrelationData(IdUtil.objectId());
          rabbitTemplate.convertAndSend(ConfirmConfig.EXCHANGE_NAME, ConfirmConfig.ROUTING_KEY, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", ConfirmConfig.EXCHANGE_NAME, ConfirmConfig.ROUTING_KEY, msg);
  
          correlationData = new CorrelationData(IdUtil.objectId());
          String exchangeName = ConfirmConfig.EXCHANGE_NAME.concat(IdUtil.objectId());
          rabbitTemplate.convertAndSend(exchangeName, ConfirmConfig.ROUTING_KEY, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", exchangeName, ConfirmConfig.ROUTING_KEY, msg);
      }
  }
  
  ~~~

  

- 消费者

  ~~~java
  import com.lemonzuo.config.ConfirmConfig;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.core.Message;
  import org.springframework.amqp.rabbit.annotation.RabbitListener;
  import org.springframework.stereotype.Component;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 23:48
   */
  @Slf4j
  @Component
  public class ConfirmConsumer {
      @RabbitListener(queues = ConfirmConfig.QUEUE_NAME)
      public void confirmReceiveMessage(Message message) {
          String msg = new String(message.getBody());
          log.info("接收到的消息内容为:{}", msg);
      }
  }
  ~~~

  

## 队列消息退回

- application.yml

  ~~~yaml
  spring:
    rabbitmq:
      # 消息退回
      publisher-returns: true
  ~~~

  

- 配置类

  ~~~java
  import org.springframework.amqp.core.*;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  /**
   * 发布确认配置
   * @author LemonZuo
   * @create 2022-01-02 23:31
   */
  @Configuration
  public class ConfirmConfig {
      public static final String EXCHANGE_NAME = "confirm.exchange";
      public static final String QUEUE_NAME = "confirm.queue";
      public static final String ROUTING_KEY = "confirm.routing.key";
  
      @Bean
      public Exchange confirmExchange() {
          return new DirectExchange(EXCHANGE_NAME, true, false);
      }
  
      @Bean
      public Queue confirmQueue() {
          return QueueBuilder.durable(QUEUE_NAME).build();
      }
  
      @Bean
      public Binding confirmBinding(Queue confirmQueue, Exchange confirmExchange) {
          return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(ROUTING_KEY).noargs();
      }
  }
  ~~~

  

- 生产者

  ~~~java
  import cn.hutool.core.util.IdUtil;
  import com.lemonzuo.config.ConfirmConfig;
  import io.swagger.annotations.Api;
  import io.swagger.annotations.ApiImplicitParam;
  import io.swagger.annotations.ApiImplicitParams;
  import io.swagger.annotations.ApiOperation;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.rabbit.connection.CorrelationData;
  import org.springframework.amqp.rabbit.core.RabbitTemplate;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PathVariable;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  import javax.annotation.Resource;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 23:44
   */
  @Slf4j
  @RestController
  @Api(tags = "消息发布确认")
  @RequestMapping("/confirm")
  public class ConfirmController {
      @Resource
      private RabbitTemplate rabbitTemplate;
  
      @ApiOperation("发送发布确认消息")
      @ApiImplicitParams({
           @ApiImplicitParam(name = "msg", value = "消息内容", paramType = "path")
      })
      @GetMapping("/sendConfirmMessage/{msg}")
      public void sendConfirmMessage(@PathVariable String msg) {
          // 队列消息退回
          rabbitTemplate.setReturnsCallback(returnCallback -> {
              log.info("消息:{}被服务器退回,退回原因:{},交换机:{},路由Key:{}", returnCallback.getMessage().getBody(), returnCallback.getReplyText(), returnCallback.getExchange(), returnCallback.getRoutingKey());
          });
          CorrelationData correlationData = new CorrelationData(IdUtil.objectId());
          rabbitTemplate.convertAndSend(ConfirmConfig.EXCHANGE_NAME, ConfirmConfig.ROUTING_KEY, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", ConfirmConfig.EXCHANGE_NAME, ConfirmConfig.ROUTING_KEY, msg);
  
          String routingKey = ConfirmConfig.ROUTING_KEY.concat(IdUtil.objectId());
          correlationData = new CorrelationData(IdUtil.objectId());
          rabbitTemplate.convertAndSend(ConfirmConfig.EXCHANGE_NAME, routingKey, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", ConfirmConfig.EXCHANGE_NAME, routingKey, msg);
  
      }
  }
  
  ~~~

  

- 消费者

  ~~~java
  import com.lemonzuo.config.ConfirmConfig;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.core.Message;
  import org.springframework.amqp.rabbit.annotation.RabbitListener;
  import org.springframework.stereotype.Component;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 23:48
   */
  @Slf4j
  @Component
  public class ConfirmConsumer {
      @RabbitListener(queues = ConfirmConfig.QUEUE_NAME)
      public void confirmReceiveMessage(Message message) {
          String msg = new String(message.getBody());
          log.info("接收到的消息内容为:{}", msg);
      }
  }
  ~~~

# 交换机备份

- 架构图

  ![image-20220103163438449](https://img-file.lemonzuo.com/img/202201031634496.png)

- 配置类

  ~~~java
  import org.springframework.amqp.core.*;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  /**
   * 发布确认配置
   * @author LemonZuo
   * @create 2022-01-02 23:31
   */
  @Configuration
  public class ConfirmConfig {
      public static final String EXCHANGE_NAME = "confirm.exchange";
      public static final String BACK_EXCHANGE_NAME = "back.exchange";
      public static final String QUEUE_NAME = "confirm.queue";
      public static final String ROUTING_KEY = "confirm.routing.key";
      public static final String BACKUP_QUEUE_NAME = "back.queue";
      public static final String WARNING_QUEUE_NAME = "warning.queue";
  
      @Bean
      public Exchange confirmExchange() {
          // 不使用交换机备份时使用
          // return new DirectExchange(EXCHANGE_NAME, true, false);
          // 使用交换机备份时使用
          // ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(true).withArgument("alternate-exchange", BACK_EXCHANGE_NAME).build();
          return ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(true).alternate(BACK_EXCHANGE_NAME).build();
      }
  
      @Bean
      public Queue confirmQueue() {
          return QueueBuilder.durable(QUEUE_NAME).build();
      }
  
      @Bean
      public Binding confirmBinding(Queue confirmQueue, Exchange confirmExchange) {
          return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(ROUTING_KEY).noargs();
      }
  
      @Bean
      public Exchange backupExchange() {
          return new FanoutExchange(BACK_EXCHANGE_NAME, true, false);
      }
  
      @Bean
      public Queue backupQueue() {
          return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();
      }
  
      @Bean
      public Queue warningQueue() {
          return QueueBuilder.durable(WARNING_QUEUE_NAME).build();
      }
  
      @Bean
      public Binding backupBinding(Queue backupQueue, Exchange backupExchange) {
          return BindingBuilder.bind(backupQueue).to(backupExchange).with("").noargs();
      }
  
      @Bean
      public Binding warningBinding(Queue warningQueue, Exchange backupExchange) {
          return BindingBuilder.bind(warningQueue).to(backupExchange).with("").noargs();
      }
  }
  ~~~

  

- 生产者

  ~~~java
  import cn.hutool.core.util.IdUtil;
  import com.lemonzuo.config.ConfirmConfig;
  import io.swagger.annotations.Api;
  import io.swagger.annotations.ApiImplicitParam;
  import io.swagger.annotations.ApiImplicitParams;
  import io.swagger.annotations.ApiOperation;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.rabbit.connection.CorrelationData;
  import org.springframework.amqp.rabbit.core.RabbitTemplate;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.PathVariable;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  import javax.annotation.Resource;
  
  /**
   * @author LemonZuo
   * @create 2022-01-02 23:44
   */
  @Slf4j
  @RestController
  @Api(tags = "消息发布确认")
  @RequestMapping("/confirm")
  public class ConfirmController {
      @Resource
      private RabbitTemplate rabbitTemplate;
  
      @ApiOperation("发送发布确认消息")
      @ApiImplicitParams({
           @ApiImplicitParam(name = "msg", value = "消息内容", paramType = "path")
      })
      @GetMapping("/sendConfirmMessage/{msg}")
      public void sendConfirmMessage(@PathVariable String msg) {
          // 交换机消息发布确认
          rabbitTemplate.setConfirmCallback((CorrelationData correlationData, boolean ack, String cause) -> {
              if (ack) {
                  log.info("交换机接收消息成功: ID:{}", (correlationData != null ? correlationData.getId() : ""));
              } else {
                  log.info("交换机未收到Id:{}的消息，原因:{}", (correlationData != null ? correlationData.getId() : ""), cause);
              }
          });
          // 队列消息退回
          rabbitTemplate.setReturnsCallback(returnCallback -> {
              log.info("消息:{}被服务器退回,退回原因:{},交换机:{},路由Key:{}", returnCallback.getMessage().getBody(), returnCallback.getReplyText(), returnCallback.getExchange(), returnCallback.getRoutingKey());
          });
          CorrelationData correlationData = new CorrelationData(IdUtil.objectId());
          rabbitTemplate.convertAndSend(ConfirmConfig.EXCHANGE_NAME, ConfirmConfig.ROUTING_KEY, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", ConfirmConfig.EXCHANGE_NAME, ConfirmConfig.ROUTING_KEY, msg);
  
          correlationData = new CorrelationData(IdUtil.objectId());
          String exchangeName = ConfirmConfig.EXCHANGE_NAME.concat(IdUtil.objectId());
          rabbitTemplate.convertAndSend(exchangeName, ConfirmConfig.ROUTING_KEY, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", exchangeName, ConfirmConfig.ROUTING_KEY, msg);
  
          String routingKey = ConfirmConfig.ROUTING_KEY.concat(IdUtil.objectId());
          correlationData = new CorrelationData(IdUtil.objectId());
          rabbitTemplate.convertAndSend(ConfirmConfig.EXCHANGE_NAME, routingKey, msg, correlationData);
          log.info("exchangeName:{}, routingKey:{}, 发送消息内容为:{}", ConfirmConfig.EXCHANGE_NAME, routingKey, msg);
  
      }
  }
  ~~~

  

- 消费者

  ~~~java
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.amqp.core.Message;
  import org.springframework.amqp.rabbit.annotation.RabbitListener;
  import org.springframework.stereotype.Component;
  
  /**
   * @author LemonZuo
   * @create 2022-01-03 16:30
   */
  @Component
  @Slf4j
  public class WarningConsumer {
      public static final String WARNING_QUEUE_NAME = "warning.queue";
  
      @RabbitListener(queues = WARNING_QUEUE_NAME)
      public void receiveWarningMsg(Message message) {
          String msg = new String(message.getBody());
          log.error("报警发现不可路由消息:{}", msg);
      }
  }
  ~~~

  
