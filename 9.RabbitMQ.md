# 下载安装

> 官网地址：https://www.rabbitmq.com/
>
> 下载地址：https://www.rabbitmq.com/download.html

# 图像化管理界面

- 图像化界面

![image-20210415212356291](https://img-file.lemonzuo.com/img/20210415212356.png)

# 简单模式

- pom依赖

    ~~~xml
    <dependency>
        <groupId>com.rabbitmq</groupId>
        <artifactId>amqp-client</artifactId>
        <version>5.10.0</version>
    </dependency>
    ~~~

- 生产者

    ~~~java
    public class Producer {
        private static final String QUEUE_NAME = "SIMPLE_MODEL";
    
        public static void main(String[] args) {
            Connection connection = null;
            Channel channel = null;
            try {
                // 1.创建连接工厂
                ConnectionFactory factory = new ConnectionFactory();
                factory.setHost("8.134.12.132");
                factory.setPort(5672);
                factory.setUsername("admin");
                factory.setPassword("admin");
                factory.setVirtualHost("/");
                // 2.创建连接Connection
                connection = factory.newConnection("producer");
                // 3.创建通道Channel
                channel = connection.createChannel();
                // 4.创建交换机，声明队列，绑定关系，路由key,发送消息，接收消息
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                channel.queueDeclare(QUEUE_NAME, false, false, false, null);
                // 5.准备消息内容
                String message = "RabbitMQ";
                // 6.发送消息给队列
                // 参数一：发送到哪一个交换机
                // 参数二：路由的key值，本次是队列名称
                // 参数三：其他参数信息
                // 参数四：待发送消息的消息体
                channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
                System.out.println("消息发送成功=====>");
            } catch (IOException | TimeoutException e) {
                e.printStackTrace();
            } finally {
                // 7.关闭通道
                if (channel != null && channel.isOpen()) {
                    try {
                        channel.close();
                    } catch (IOException | TimeoutException e) {
                        e.printStackTrace();
                    }
                }
                // 8.关闭连接
                if (connection != null && connection.isOpen()) {
                    try {
                        connection.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class Consumer {
        private static final String QUEUE_NAME = "SIMPLE_MODEL";
    
        public static void main(String[] args) {
            Connection connection = null;
            Channel channel = null;
            try {
                // 1.创建连接工厂
                ConnectionFactory factory = new ConnectionFactory();
                factory.setHost("8.134.12.132");
                factory.setPort(5672);
                factory.setUsername("admin");
                factory.setPassword("admin");
                factory.setVirtualHost("/");
                // 2.创建连接Connection
                connection = factory.newConnection("producer");
                // 3.创建通道Channel
                channel = connection.createChannel();
                // 4. 接收消息
                // 消费成功
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    System.out.println("收到的消息为========>");
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                };
                // 取消消费
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费消息");
                };
                // 参数一：消费的队列名称
                // 参数二：消费成功后是否自动应答
                // 参数三：消费者消费成功回调
                // 参数四：消费者取消消费回调
                channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
            } catch (IOException | TimeoutException e) {
                e.printStackTrace();
            } finally {
                // 5.关闭通道
                if (channel != null && channel.isOpen()) {
                    try {
                        channel.close();
                    } catch (IOException | TimeoutException e) {
                        e.printStackTrace();
                    }
                }
                // 6.关闭连接
                if (connection != null && connection.isOpen()) {
                    try {
                        connection.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ~~~
    
# 工作队列模式

1. 自动应答

    - 生产者

        ~~~java
        public class Task01 {
            private static final String QUEUE_NAME = "WORK_MODEL";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                channel.queueDeclare(QUEUE_NAME, false, false, false, null);
                for (int i = 1; i <= 10; i++) {
                    channel.basicPublish("", QUEUE_NAME, null, String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消费者

        ~~~java
        public class Work01 {
            private static final String QUEUE_NAME = "WORK_MODEL";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 消费成功
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    System.out.println("收到的消息为========>");
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                };
                // 取消消费
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费消息");
                };
                System.out.println("WORK-2-start");
                // 异步执行消费
                channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
                System.out.println("WORK-2-end");
            }
        }
        ~~~

        

2. 手动应答

    - 生产者

        ~~~java
        public class Task02 {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                channel.queueDeclare(QUEUE_NAME, false, false, false, null);
                for (int i = 11; i <= 20; i++) {
                    channel.basicPublish("", QUEUE_NAME, null, String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消费者

        ~~~java
        public class Work02 {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                System.out.println("WORK-2-start");
                Channel channel = RabbitMqUtils.getChannel();
                // 消费成功
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("收到的消息为========>");
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    // 消息的标记
                    long deliveryTag = message.getEnvelope().getDeliveryTag();
                    // 是否批量应答本信道内所有消息
                    boolean multiple = false;
                    // 执行应答
                    channel.basicAck(deliveryTag, multiple);
                };
                // 取消消费
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费消息");
                };
                // 异步执行消费,手动应答
                channel.basicConsume(QUEUE_NAME, false, deliverCallback, cancelCallback);
            }
        }
        ~~~

        

3. 数据持久化

    - 队列持久化

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-03 22:54
         * 队列持久化
         */
        public class TaskQueueDurable {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK_DURABLE";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                // 队列持久化
                boolean durable = true;
                channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
                for (int i = 11; i <= 20; i++) {
                    channel.basicPublish("", QUEUE_NAME, null, String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消息持久化

        ~~~java
        public class TaskQueueAndMessageDurable {
            private static final String QUEUE_NAME = "WORK_MODEL_ACK_QUEUE_MESSAGE_DURABLE";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                // 队列持久化
                boolean durable = true;
                channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
                for (int i = 11; i <= 20; i++) {
                    // 发送消息，且持久化消息
                    // 新增MessageProperties.PERSISTENT_TEXT_PLAIN
                    channel.basicPublish("", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,
                            String.valueOf(i).getBytes(StandardCharsets.UTF_8));
                }
                System.out.println("消息发送完毕");
            }
        }
        ~~~

4. 不公平分发

    ~~~java
    /**
     * @author LemonZuo
     * @create 2021-07-03 22:45
     * 不公平分发
     */
    public class WorkPrefetch {
        private static final String QUEUE_NAME = "WORK_MODEL_ACK";
    
        public static void main(String[] args) throws IOException, TimeoutException {
            System.out.println("WORK-3-start");
            Channel channel = RabbitMqUtils.getChannel();
            // 消费成功
            DeliverCallback deliverCallback = (consumerTag, message) -> {
                try {
                    TimeUnit.SECONDS.sleep(30);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("收到的消息为========>");
                System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                // 消息的标记
                long deliveryTag = message.getEnvelope().getDeliveryTag();
                // 是否批量应答本信道内所有消息
                boolean multiple = false;
                // 执行应答
                channel.basicAck(deliveryTag, multiple);
            };
            // 取消消费
            CancelCallback cancelCallback = consumerTag -> {
                System.out.println("取消消费消息");
            };
            // 不公平分发
            int prefetch = 1;
            channel.basicQos(prefetch);
            // 异步执行消费,手动应答
            channel.basicConsume(QUEUE_NAME, false, deliverCallback, cancelCallback);
        }
    }
    ~~~

5. 预取值

    - 生产者

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-03 22:54
         * 预取值
         */
        public class Task {
            private static final String QUEUE_NAME = "WORK_MODEL_PREFETCH";
        
            public static void main(String[] args) throws IOException, TimeoutException {
                Channel channel = RabbitMqUtils.getChannel();
                // 参数一：队列名称
                // 参数二：队列中消息是否持久化
                // 参数三：队列是否支持多消费者消费、是否进行消息共享
                // 参数四：是否自动删除 最后一个消费者断开连接后是否自动删除
                // 参数五：其他参数
                // 队列持久化
                boolean durable = true;
                channel.queueDeclare(QUEUE_NAME, durable, false, false, null);
                Scanner scanner = new Scanner(System.in);
                String str;
                do {
                    str = scanner.next();
                    // 发送消息，且持久化消息
                    // 新增MessageProperties.PERSISTENT_TEXT_PLAIN
                    channel.basicPublish("", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, str.getBytes(StandardCharsets.UTF_8));
                } while (!"end".equalsIgnoreCase(str));
                System.out.println("消息发送完毕");
            }
        }
        ~~~

        

    - 消费者

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-04 11:34
         */
        public class Work01 {
            private static final String QUEUE_NAME = "WORK_MODEL_PREFETCH";
        
            public static void main(String[] args) {
                Channel channel = RabbitMqUtils.getChannel();
        
                try {
                    TimeUnit.SECONDS.sleep(1);
                    assert channel != null;
                    // prefetchCount: 0-公平/轮询分发，1-不公平分发，>=2 -预取值
                    int prefetchCount = 2;
                    channel.basicQos(prefetchCount);
                    DeliverCallback deliverCallback = (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                        long deliveryTag = message.getEnvelope().getDeliveryTag();
                        channel.basicAck(deliveryTag, false);
                    };
                    channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

6. 发布确认

    - 生产者

        ~~~java
        public class ConfirmMessage {
            public static void main(String[] args) {
                // 单个确认 11312MS
                // confirmSingle();
                // 批量发布确认 200MS
                // confirmBatch();
                // 异步确认 120MS
                // confirmAsync();
            }
        
            public static void confirmSingle() {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 开启发布确认
                    channel.confirmSelect();
                    // 60e164ef22158c3ee7788a69
                    String queueName = IdUtil.objectId();
                    // 申明队列
                    channel.queueDeclare(queueName, true, false, false, null);
                    TimeInterval timer = DateUtil.timer();
                    for (int i = 0; i < 1000; i++) {
                        String message = String.valueOf(i);
                        channel.basicPublish("", queueName, MessageProperties.PERSISTENT_TEXT_PLAIN,
                                message.getBytes(StandardCharsets.UTF_8));
                        boolean confirms = channel.waitForConfirms();
                        if (confirms) {
                            System.out.println("发布消息成功");
                        }
                    }
                    System.out.println("耗时：" + timer.interval());
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
        
            public static void confirmBatch() {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 开启发布确认
                    channel.confirmSelect();
                    // 60e167db22159c5f90a586ac
                    String queueName = IdUtil.objectId();
                    // 申明队列
                    channel.queueDeclare(queueName, true, false, false, null);
                    // 批量大小
                    int batchSize = 100;
                    TimeInterval timer = DateUtil.timer();
                    for (int i = 0; i < 1000; i++) {
                        String message = String.valueOf(i);
                        channel.basicPublish("", queueName, MessageProperties.PERSISTENT_TEXT_PLAIN,
                                message.getBytes(StandardCharsets.UTF_8));
                        if ((i + 1) % batchSize == 0) {
                            boolean confirms = channel.waitForConfirms();
                            if (confirms) {
                                System.out.println("发布消息成功");
                            }
                        }
                    }
                    System.out.println("耗时：" + timer.interval());
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
        
            public static void confirmAsync() {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 开启发布确认
                    channel.confirmSelect();
                    // 线程安全有序的哈希表
                    ConcurrentSkipListMap<Long, String> container = new ConcurrentSkipListMap<>();
                    // 60e16b132215319e0d197747
                    String queueName = IdUtil.objectId();
                    // 申明队列
                    channel.queueDeclare(queueName, true, false, false, null);
                    // 消息监听器
                    // 成功回调
                    ConfirmCallback ackCallback = (deliveryTag, multiple) -> {
                        System.out.println("确认的消息编号：" + deliveryTag);
                        if (multiple) {
                            ConcurrentNavigableMap<Long, String> confirmed = container.headMap(deliveryTag);
                            confirmed.clear();
                        } else {
                            container.remove(deliveryTag);
                        }
                    };
                    // 失败回调
                    ConfirmCallback nackCallback = (deliveryTag, multiple) -> {
                        System.out.println("未确认的消息编号：" + deliveryTag);
                    };
                    channel.addConfirmListener(ackCallback, nackCallback);
                    TimeInterval timer = DateUtil.timer();
                    for (int i = 0; i < 1000; i++) {
                        String message = String.valueOf(i);
                        channel.basicPublish("", queueName, MessageProperties.PERSISTENT_TEXT_PLAIN,
                                message.getBytes(StandardCharsets.UTF_8));
                        container.put(channel.getNextPublishSeqNo(), message);
                    }
                    System.out.println("耗时：" + timer.interval());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

# 发布订阅模式

- 生产者

    ~~~java
    /**
     * @author LemonZuo
     * @create 2021-07-04 23:23
     */
    public class EmitLog {
        private final static String EXCHANGE_NAME = "logs";
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
                Scanner scanner = new Scanner(System.in);
                while (scanner.hasNext()) {
                    String message = scanner.next();
                    // 推送消息
                    channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes(StandardCharsets.UTF_8));
                    System.out.println("消息推送成功：".concat(message));
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class ReceiveLog01 {
        private final static String EXCHANGE_NAME = "logs";
    
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
                // 生成临时队列
                String queueName = channel.queueDeclare().getQueue();
                // 交换机与队列进行绑定
                channel.queueBind(queueName, EXCHANGE_NAME, "");
                // 消费成功回调
                DeliverCallback deliverCallback = (consumerTag, message) -> {
                    System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                };
                // 取消消费回调
                CancelCallback cancelCallback = consumerTag -> {
                    System.out.println("取消消费");
                };
                // 接收消息
                System.out.println("ReceiveLog-01 等待接收消息");
                channel.basicConsume(queueName, deliverCallback, cancelCallback);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~



# 直接模式

- 生产者

    ~~~java
    public class DirectLog {
        private final static String EXCHANGE_NAME = "DIRECT_LOG";
    
        public static void main(String[] args) {
            try {
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                Scanner scanner = new Scanner(System.in);
                while (scanner.hasNext()) {
                    String message = scanner.next();
                    String[] str = message.split(";");
    
                    // 推送消息
                    channel.basicPublish(EXCHANGE_NAME, str[0], null, str[1].getBytes(StandardCharsets.UTF_8));
                    System.out.println("消息推送成功：消息类型".concat(str[0]).concat(" 消息内容：").concat(str[1]));
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class ReceiveConsoleLog {
        private final static String EXCHANGE_NAME = "DIRECT_LOG";
    
        public static void main(String[] args) {
            try {
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明直接交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                channel.queueDeclare("console", false, false, false, null);
                channel.queueBind("console", EXCHANGE_NAME, "info");
                channel.queueBind("console", EXCHANGE_NAME, "warn");
                System.out.println("等待接收消息");
                channel.basicConsume("console",
                        (consumerTag, message) -> System.out.println(new String(message.getBody(), StandardCharsets.UTF_8)),
                        consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    ~~~java
    public class ReceiveErrorLog {
        private final static String EXCHANGE_NAME = "DIRECT_LOG";
    
        public static void main(String[] args) {
            try {
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明直接交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                channel.queueDeclare("disk", false, false, false, null);
                channel.queueBind("disk", EXCHANGE_NAME, "error");
                System.out.println("等待接收消息");
                channel.basicConsume("disk",
                        (consumerTag, message) -> System.out.println(new String(message.getBody(), StandardCharsets.UTF_8)),
                        consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

# 主题模式

- 生产者

    ~~~java
    public class EmitLogs {
        private static final String EXCHANGE_NAME = "topic_logs";
    
        public static void main(String[] args) {
            Map<String, String> messages = new HashMap<>();
            messages.put("quick.orange.rabbit", "被队列 Q1Q2 接收到");
            messages.put("lazy.orange.elephant", "被队列 Q1Q2 接收到");
            messages.put("quick.orange.fox", "被队列 Q1 接收到");
            messages.put("azy.brown.fox", "被队列 Q2 接收到");
            messages.put("lazy.pink.rabbit", "虽然满足两个绑定但只被队列 Q2 接收一次");
            messages.put("quick.brown.fox", "不匹配任何绑定不会被任何队列接收到会被丢弃");
            messages.put("quick.orange.male.rabbit", "是四个单词不匹配任何绑定会被丢弃");
            messages.put("lazy.orange.male.rabbit", "是四个单词但匹配 Q2");
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明主题交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
                messages.forEach((key, value) -> {
                    try {
                        // 推送消息
                        channel.basicPublish(EXCHANGE_NAME, key, null, value.getBytes(StandardCharsets.UTF_8));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    

- 消费者

    ~~~java
    public class TopicReceiveLog01 {
        private static final String EXCHANGE_NAME = "topic_logs";
    
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明主题交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
                // 声明队列
                channel.queueDeclare("Q1", false, false, false, null);
                // 交换机绑定队列
                channel.queueBind("Q1", EXCHANGE_NAME, "*.orange.*");
                channel.basicConsume("Q1", true, (consumerTag, message) -> {
                    System.out.println("routeKey: ".concat(message.getEnvelope().getRoutingKey()).concat(" message:").concat(new String(message.getBody(), StandardCharsets.UTF_8)));
                },consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~

    ~~~java
    public class TopicReceiveLog02 {
        private static final String EXCHANGE_NAME = "topic_logs";
        public static void main(String[] args) {
            try {
                // 获取信道
                Channel channel = RabbitMqUtils.getChannel();
                assert channel != null;
                // 声明主题交换机
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
                // 声明队列
                channel.queueDeclare("Q2", false, false, false, null);
                // 交换机绑定队列
                channel.queueBind("Q2", EXCHANGE_NAME, "*.*.rabbit");
                channel.queueBind("Q2", EXCHANGE_NAME, "lazy.#");
                channel.basicConsume("Q2", true, (consumerTag, message) -> {
                    System.out.println("routeKey: ".concat(message.getEnvelope().getRoutingKey()).concat(" message:").concat(new String(message.getBody(), StandardCharsets.UTF_8)));
                },consumerTag -> System.out.println("取消消费"));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ~~~



# 死信队列

- 消息超时

    - 生产者

        ~~~java
        public class Producer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 构建超时参数 单位毫秒
                    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                            .expiration("10000").build();
                    for (int i = 1; i < 11; i++) {
                        String message = "info" + i;
                        channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, properties, message.getBytes(StandardCharsets.UTF_8));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 普通消费者

        ~~~java
        public class NormalConsumer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        
        
                    // 声明普通交换机
                    channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明普通队列
                    Map<String, Object> arguments = new HashMap<>(4);
                    // 绑定死信交换机
                    arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
                    // 死信队列使用的routing-key
                    arguments.put("x-dead-letter-routing-key", DEAD_ROUTING_KEY);
        
                    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        
                    // 普通交换机与普通队列绑定
                    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
                    System.out.println("普通消费者等待接收消息");
                    channel.basicConsume(NORMAL_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 死信消费者

        ~~~java
        public class DeadConsumer {
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    // 死信交换机与死信队列绑定
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
                    System.out.println("死信消费者等待接收消息");
                    channel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

- 队列达最大长度

    - 生产者

        ~~~java
        public class Producer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 构建超时参数 单位毫秒
                    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                            .expiration("10000").build();
                    for (int i = 1; i < 11; i++) {
                        String message = "info" + i;
                        channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, null, message.getBytes(StandardCharsets.UTF_8));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 正常消费者

        ~~~java
        /**
         * @author LemonZuo
         * @create 2021-07-06 12:46
         * 死信队列正常消费者
         */
        public class NormalConsumerMaxLength {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        
        
                    // 声明普通交换机
                    channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明普通队列
                    Map<String, Object> arguments = new HashMap<>(4);
                    // 绑定死信交换机
                    arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
                    // 死信队列使用的routing-key
                    arguments.put("x-dead-letter-routing-key", DEAD_ROUTING_KEY);
                    // 队列最大长度
                    arguments.put("x-max-length", 6);
        
                    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        
                    // 普通交换机与普通队列绑定
                    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
                    System.out.println("普通消费者等待接收消息");
                    channel.basicConsume(NORMAL_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 死信消费者

        ~~~java
        public class DeadConsumer {
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    // 死信交换机与死信队列绑定
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
                    System.out.println("死信消费者等待接收消息");
                    channel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

- 消息被拒

    - 生产者

        ~~~java
        public class Producer {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 构建超时参数 单位毫秒
                    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                            .expiration("10000").build();
                    for (int i = 1; i < 11; i++) {
                        String message = "info" + i;
                        channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, null, message.getBytes(StandardCharsets.UTF_8));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 正常消费者

        ~~~java
        public class NormalConsumerReject {
            private static final String NORMAL_EXCHANGE = "normal_exchange";
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String NORMAL_QUEUE = "normal_queue";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String NORMAL_ROUTING_KEY = "normal";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        
        
                    // 声明普通交换机
                    channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明普通队列
                    Map<String, Object> arguments = new HashMap<>(4);
                    // 绑定死信交换机
                    arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);
                    // 死信队列使用的routing-key
                    arguments.put("x-dead-letter-routing-key", DEAD_ROUTING_KEY);
        
                    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
        
                    // 普通交换机与普通队列绑定
                    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
                    System.out.println("普通消费者等待接收消息");
                    channel.basicConsume(NORMAL_QUEUE, false, (consumerTag, message) -> {
                        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
                        // 拒绝消息
                        if ("info5".equals(msg)) {
                            channel.basicReject(message.getEnvelope().getDeliveryTag(), false);
                        } else {
                            System.out.println(msg);
                            channel.basicAck(message.getEnvelope().getDeliveryTag(), false);
                        }
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

    - 死信 消费者

        ~~~java
        public class DeadConsumer {
            private static final String DEAD_EXCHANGE = "dead_exchange";
            private static final String DEAD_QUEUE = "dead_queue";
            private static final String DEAD_ROUTING_KEY = "dead";
        
            public static void main(String[] args) {
                try {
                    Channel channel = RabbitMqUtils.getChannel();
                    assert channel != null;
                    // 声明死信交换机
                    channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
                    // 声明死信队列
                    channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
                    // 死信交换机与死信队列绑定
                    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
                    System.out.println("死信消费者等待接收消息");
                    channel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {
                        System.out.println(new String(message.getBody(), StandardCharsets.UTF_8));
                    }, consumerTag -> {
                        System.out.println("取消消费");
                    });
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ~~~

        

# 整合SpringBoot

